## Transcript 1 (panopto)
Source: https://jh.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=60b7f7b9-9be4-4feb-bd02-b0c4014124a7

So while the main engines search
for constraint satisfaction problems
or backtracking and forward checking.
We can ask ourselves, can we add
any other smart things to
make backtracking and
forward checking search better?
And to answer that question,
we're going to take a slightly different view
of constraint satisfaction problems.
And we'll look at them in terms
of a constraint graph.
So we have our variables.
This is for the four queens problem.
We have our forbear variables are a or B,
or C or D.
And these will be nodes in the graph.
And then anytime there's
a constraint between the variables,
we draw an arc between the nodes.
Now in this case, because of
the four queens problem,
there are constraints
between all the variables.
We will actually end up
with a complete graph.
So there is a node from
every node to every other node in this graph.
This is not always the case.
So for example, you might have a node here,
a and b with no arc between them.
And that would simply mean
that they don't have a constraint.
That I'm sure constraint.
Now this also means, and this is true of
constraint satisfaction problems in general,
that all the constraints need to be
formulated or reformulated
it binary constraints.
So any higher-order constraints higher than
binary must be reformulated
as binary constraints.
Now we say a node is arc consistent if
all of the values in
its domain do not
violate any of its constraints.
And the way that we make
a node arc consistent is simply by
eliminating values
do violate its constraints.
And this is essentially
what forward is checking has been doing.
Forward checking uses
a simple form of arc consistency.
However, arc consistency can be
extended by applying it
iteratively to check all of
the arcs whenever an assignment is made.
And this is the approach
of the algorithm AC3,
which does inference over constraints.
So we have backtracking and forward checking.
And what else can we do?
How can we make it better?
The first question then
that comes to mind is,
is there a better way to pick the variables?
So let's think about that a little bit more.
Suppose we had the following
constraint satisfaction problem.
So we're going to have 45 variables,
a, B, C, D, and E.
And these are nodes.
And we're going to have
the following constraints
between them, represented by arcs.
And we can specify
their domains next to
them as sets to five values.
Now it's important to note
that we don't create
beast constraint graphs in order to
solve constraint satisfaction problems.
This is the zone implicit.
Let's make a copy of this
that we can use it later.
Now in our previous examples,
we picked variables and values in order.
In fact, we, we pick them in a static order.
Now there's nothing inherent
in the problem that requires a do this.
But let's see if
doing what we did essentially
picking a from a,
B, C, D, and then one from one to three.
We can ask ourselves,
is, is this a good idea?
So here's our constraint
satisfaction problem.
Let's start with a minus sign
and the value of one.
And then use forward
checking to all the variables.
Shares constraint with.
We'll go to b and assign it the value of
two and use forward checking again.
Lead us to see.
And then we find out that sees domain
is empty and that's when we would backtrack.
So as this leads us to
question whether using a static order is,
is a good idea if it's the best way or
perhaps there's some other way
that we can pick variables.
So one approach that comes to mind,
what if we picked the variable
with the smallest domain?
And then we, if there are ties,
we will just simply break them at
random or in some static order.
So here's our constraint
satisfaction problem again.
And smallest domains or,
or size of two.
And let's just pick D and
assigned the value three in US forward
checking at leads us to either a or C.
And let's pick a sign of
the value of one and use forward checking.
Now we have C has a domain of just one,
and we can assign it a value of two.
And this forward checking DB
has a size of two.
We can sign it three
and use forward checking.
Oops, missed the two they're used for,
we're checking for B and
for E we can say the value of three.
And there we have
a complete consistent assignment.
Remember, we're going to break ties
randomly or some static order.
And this approach actually has a name,
it's called minimum remaining values or MMRV.
So you pick the variable with
the minimum remaining values,
break ties randomly,
or in a static quarter.
There are alternatives.
What if we pick
the most constrained variable?
That is, we want to pick
the variable that participates
in the largest number of constraints.
So here we have
a constraint satisfaction problem
again. Hello.
See participates in or constraints.
So we should assign a new value first we
assign the value one and use for rechecking.
A participates in three constraints.
So we assign the value of
two and use forward checking.
Now, B and D are tied,
we're going to be assigned the value of
three and use forward checking.
D we can assign,
we can pick next because
it has two constraints,
Santa value of three US forward checking.
And finally we'll go, he only has
one constraint saying that the value of two.
Here again, we have
a complete consistent assignment
of values.
And this is called the degree heuristic,
which again basically has the idea
to pick the variable
that has the fewest options,
the fewer slack because
participates in
the largest number of constraints.
Now that we've picked a variable,
we can ask ourselves how,
what's the best value one?
So similarly, we picked variable
using minimum remaining values
or some other approach.
What value should we pick?
We use a static orders.
We can we pick more intelligently?
So what if we pick the value that
rules out the fewest other
about the fewest other values
for the other variables.
Constraints.
So let's see what that means here.
We'll pick the,
our constraint satisfaction problem.
We're going to use the same order for
a minimum remaining values.
We're gonna start with D and we look at three
and D and a share three as values.
But if we look at for,
D doesn't share for
as a value on any
other variable that's constrained width.
So we should pick four and assign that to D.
Now we're going to look at one.
We said that one is shared with
two constraints and twos
shared with two constraint to share with you.
One is shared with two variables
through shared with three variables.
Let's go ahead and pick one for C.
And we need to apply for a check here.
We didn't need to do it for t
because it didn't share for with anything.
So still use forward checking.
Go ahead and look at a and
we see it shares with B.
It also shares three with B,
shares three with d.
So we should pick to assign that to a.
Now, we use for rechecking again.
B we can look at, we have
three in e we assigned to.
So this is called the least
constraining value.

## Transcript 2 (panopto)
Source: https://jh.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=16df7c61-4002-4968-a252-b0cb01471c1d

So in our previous video,
what we really did is we
made forward checking a
little bit smarter or at
least how to pick the variable smarter.
So now we can ask ourselves,
can we make backtracking smarter?
I suppose means we need to ask ourselves,
is there a problem with backtracking?
Suppose we were to examine
our constraint satisfaction problem
in the order a,
b, e, d, c.
So we start out with a.
And we have three possibilities
and we pick the first one,
we pick one, and we use forward checking.
And we go to B.
And we pick two.
And we use, we're checking.
Now we're going to examine E.
And we're going to assign it
to and use forward checking.
Now we go to d and we assign it three.
And we use forward checking.
And finally we arrive at
C and we discover the domain is empty.
So it backtracking will
tell us to do is to go
immediately back to T and try and who value.
So let's try four.
We try four and we go back
to see the domain is still empty.
So now backtracking
tells us we should go back
to E. And for E we try three,
which will lead us to try
D. And that doesn't really
help because the last assignments
are not necessarily
the source of the problem.
So what if we keep track
of the source of the assignments?
So we keep track which assignments
deleted from a domain.
So using the same
constraint satisfaction problem,
we would assign 1 to a.
And when we do forward checking,
we indicated that it was a deleted one
from B's domain and
a that deleted one from thes domain.
Now we go on to b and we assign it to.
And when we do forward checking, again,
we're going to indicate in
each of the domains where two is deleted,
that it was the assignment to
be that deleted two.
Now we can assign E2 and we
can assign three to
d and indicate in a domain,
D is what remove three.
Then when we get to see
and we see that its domain is empty,
you can see that a and
B are the last ones that deleted.
And we can pick
the last one in the group and we
can jump all the way back to be.
And trying to do
an assignment to be that's different.
This list of variables tells much wish.
Assignments cause the problem.
And this allows us to do something
called conflict directed back jumping,
which improves backtracking
in constraint satisfaction problems.
And so that's the basics
of constraint satisfaction problems.
We can ask.
What are
the constraint satisfaction problems?
There's a lot of them, they're legion.
There are puzzles like Sudoku
and crypt arithmetic.
There are practical problems like
map coloring and scheduling
and all kinds of
different problems like that.
Across the different kinds of constraints.
There are global constraints.
For example, all assignments
must be different in crypt arithmetic.
So you can't sign a, one,
Two, E and S.
And in Sudoku, all rows, columns,
and blocks must be different.
For the All Def constraint.
There are resource constraints.
In a resource strain present,
the total amount of water to be used
must be less than 10 thousand liters.
There are precedence constraints.
These are often
happen in scheduling problems.
For example, the foundation needs
to be laid before the flooring.
There are disjunctive constraints,
which basically says the two things
can't happen at the same time.
So for example, painters
can't overlap with carpenters,
but we don't care which one comes first.
And some of these are
scheduling and planning problems are
better solved as planning problem.
So when scheduling problems are better
solved is planning problems,
but some can be solved
constraint in this section, problems.
And actually a lot
of constraint satisfaction approaches
are related to declarative programming,
where we specify what to do
and not necessarily how to do it.