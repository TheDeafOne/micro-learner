# Summary

- No transcript content provided; nothing to summarize.

Please paste the transcript text to receive a concise summary.

- Overview
  - Evolutionary computation: family of search algorithms inspired by biological evolution (survival of the fittest + genetic encoding).
  - Four main historical variants: evolutionary programming (1960s), evolutionary strategies (1970s), genetic algorithms (late 1970s), genetic programming (1990s).
  - No explicit successor-state function; successor generation emerges from genetic operators and encoding.

- Representation / encoding
  - Solutions expressed as genomes (linear strings of bits/characters/integers/floats or other structures such as trees or finite-state machines) and decoded to phenomes (actual solutions, e.g., board positions or map colorings).
  - Encoder/decoder pair required to map between problem solutions and genetic code.
  - Encoding influences operator design (operators must be appropriate to genome type).

- Core algorithm / loop (pseudocode steps)
  1. Generate an initial population of N random individuals (N chosen by user).
  2. Repeat until a stopping criterion (generation limit, satisfactory solution, or other):
     - Evaluate each individual with a fitness (evaluation) function.
     - Select parents (with replacement) according to a selection scheme.
     - Apply reproduction: with probability Pc perform crossover to produce children; otherwise copy parents into next generation.
     - Apply mutation to children with probability Pm (test per-child).
     - Insert children (and any copied parents) into the next generation.
  - Keep best-so-far solution available while running; many algorithms run until “good enough” rather than a fixed termination.

- Selection methods
  - Roulette-wheel (fitness-proportionate): sample by treating each individual's fitness as proportional slice of a wheel; sampling with replacement.
  - Tournament selection: uniformly sample k individuals (e.g., ~7), pick the highest-fitness among them.

- Genetic operators
  - Crossover: example one-point crossover — pick a crossover index, swap tail segments between two parents to form two children.
  - Mutation: pick a gene position and replace with a randomly chosen symbol; for real-valued encodings, mutation can be Gaussian noise.
  - Some parents may be copied unchanged (no crossover); not all children are necessarily mutated.
  - Crossover and mutation operators must match encoding (e.g., linear genome vs. tree vs. FSM).

- Parameters & variants
  - Typical example parameter values: Pc ≈ 0.9, Pm ≈ 0.05 (adjustable).
  - Evolutionary algorithms have many user-defined parameters; parameters can be made endogenous (encoded in genome, e.g., per-gene mutation rates).
  - Fitness is naturally maximized; for minimization problems transform fitness (common transform: 1 / (1 + cost)).
  - Wide variety of crossover/mutation/selection choices and many problem-specific variants.

- Examples & special notes
  - Example encodings: four-queens as vector of row positions; map coloring as vector of colors.
  - Genetic programming uses tree (AST/Lisp) encodings; evolutionary programming may use finite-state machines.
  - Many variations exist across all components (representation, operators, selection, replacement).