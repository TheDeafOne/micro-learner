### Summary

No transcript content provided ("None"); unable to produce a summary.

To proceed, paste the transcript text or upload the file. If you prefer a specific summary style (bullet points, brief outline, length), indicate that as well.

- Definition: unification(unify(P,Q)) returns Θ, a substitution list (possibly empty). Failure can be indicated by null or another failure marker; an empty list can mean no substitution was necessary.

- Example 1: unify P(a, X) and P(a, B)
  - Θ = {X → B}

- Example 2: unify P(a, X) and P(Y, B)
  - Θ = {X → B, Y → a}

- Example 3 (variables can be assigned functions): unify P(a, X) and P(Y, f(Y))
  - Θ = {Y → a, X → f(a)}

- Variable-name collision / standardization apart:
  - Variables must be renamed to fresh, unique names before unification (standardize apart).
  - Without standardizing: unify P(a, X) and P(X, B) appears to require X → a and X → B simultaneously → (apparent) failure.
  - After standardizing: P(a, X1) and P(X2, B) unify with Θ = {X1 → B, X2 → a}.

- Genuine failures:
  - Example: unify P(a, B) and P(X, X) requires X → a and X → B at once → failure.
  - Unification also fails when a variable would need to be bound to a term containing itself (occurs-check), or when constants/functions clash (e.g., needing f(a) = b when b is a different constant).

- Topic: first-order logic / predicate calculus (adds functions and variables to propositional logic)

- Basic elements
  - Constants: specific objects (e.g., KingJohn, JHU)
  - Functions: map terms to terms (e.g., leftLeg(KingJohn) returns an object)
  - Predicates: functions returning true/false (e.g., Brother(x,y) true iff x and y are brothers)
  - Variables: placeholders (x, y, z)
  - Connectives: ¬, ∧, ∨, →, ↔ (as in propositional logic)
  - Quantifiers: ∀ (for all), ∃ (there exists)
  - Equality: standard identity between terms

- Functions vs. predicates
  - Functions produce terms (objects); they do not have truth values by themselves.
  - Predicates express truth about terms (e.g., HasLeftFoot(John) is a predicate that can be true).

- Sample simple formulas
  - Parent(John, Sam) ∧ Male(John) → Father(John, Sam)
  - HasLeftFoot(John) → HasLeftLeg(John)

- Quantifier interpretation
  - ∀x P(x): P(x) holds for every relevant instantiation of x (acts like a big conjunction over the domain).
  - ∃x P(x): P(x) holds for at least one instantiation (acts like a big disjunction).
  - Universe of discourse / typing matters: restricting x to a type or adding predicates (e.g., Person(x)) avoids unintended instantiations.
  - Examples illustrating scope/meaning differences:
    - ∀x (Person(x) → Loves(x, Raymond)) = “Everyone loves Raymond.”
    - ∃x (AtUMD(x) ∧ Smart(x)) = “Someone at UMD is smart.”
    - ∃x (AtUMD(x) → Smart(x)) ≠ previous; it means “if someone exists at UMD then that person is smart” (logically different).
    - ∀x (AtJHU(x) → Smart(x)) = “Everyone at JHU is smart.”
    - ∀x (AtJHU(x) ∧ Smart(x)) = “Everyone is at JHU and everyone is smart.”

- Properties of quantifiers
  - Same quantifiers commute: ∀x ∀y P(x,y) ≡ ∀y ∀x P(x,y) (order doesn't matter if quantifiers are the same and scopes preserved).
  - Mixed quantifiers do not commute: ∃x ∀y Loves(x,y) (someone loves everyone) ≠ ∀y ∃x Loves(x,y) (for each person there is someone who loves them).
  - Duality via negation:
    - ∀x P(x) ≡ ¬∃x ¬P(x)
    - ∃x P(x) ≡ ¬∀x ¬P(x)

- Quantifiers and inference
  - Most propositional inference rules extend, but quantifiers require additional handling.
  - Universal elimination (instantiation): from ∀x P(x) infer P(c) for any appropriate constant c.
  - Existential elimination: from ∃x P(x) infer P(c) for some fresh constant c that does not appear elsewhere (Skolem constant).
  - Skolem constants are introduced to stand for an unspecified witness when eliminating ∃.

- Conversion to first-order logic:
  - Predicates: Buffalo(x), Pig(y), Slug(z), Faster(x,y).
  - Example facts: Bob is a buffalo, Pat is a pig, Steve is a slug.
  - Rule expressed as a universally quantified implication: ∀x,y (Buffalo(x) ∧ Pig(y) → Faster(x,y)).
  - Other rules: ∀y,z (Pig(y) ∧ Slug(z) → Faster(y,z)); ∀x,y,z (Faster(x,y) ∧ Faster(y,z) → Faster(x,z)).

- Logical inference primitives:
  - And-introduction (and-elimination inverse): combine truths to produce conjunctions.
  - Universal-elimination: instantiate universally quantified variables with specific constants.
  - Modus ponens: apply implication after matching antecedent to derive consequent.
  - Substitution: assign constants to variables (e.g., x ← Bob, y ← Pat).

- Forward chaining (data-driven):
  - Match left-hand sides of implications against known facts and produce new facts.
  - Steps with given facts:
    1. From Buffalo(Bob) and Pig(Pat) plus rule ∀x,y (Buffalo(x) ∧ Pig(y) → Faster(x,y)) derive Faster(Bob,Pat).
    2. From Pig(Pat) and Slug(Steve) plus rule ∀y,z (Pig(y) ∧ Slug(z) → Faster(y,z)) derive Faster(Pat,Steve).
    3. From Faster(Bob,Pat) and Faster(Pat,Steve) plus transitivity derive Faster(Bob,Steve).
  - Note: variable names in different sentences are independent (x in one rule ≠ x in another).

- Backward chaining (goal-driven):
  - Start with goal and match right-hand sides of implications to generate required subgoals (work backwards until ground facts).
  - Example: goal Faster(Bob,Steve) instantiated with x ← Bob, z ← Steve produces subgoals:
    1. Faster(Bob,y) for some y.
    2. Faster(y,Steve) for same y.
  - Instantiate the first subgoal using ∀x,y (Buffalo(x) ∧ Pig(y) → Faster(x,y)) with y ← Pat → need Buffalo(Bob) and Pig(Pat) (both true).
  - Instantiate the second subgoal using ∀y,z (Pig(y) ∧ Slug(z) → Faster(y,z)) with y ← Pat, z ← Steve → need Pig(Pat) and Slug(Steve) (both true).
  - Therefore Faster(Bob,Steve) is proven via y = Pat.

- Search behavior and limitations:
  - Inference is a state-space search over rule applications and fact manipulations.
  - Backward chaining proceeds like depth-first search, may require backtracking if bad instantiations produce contradictions or dead ends.
  - Combinatorial explosion is a practical problem due to many possible instantiations and rule applications.

- Environment
  - Grid-world with pits, one Wumpus, one gold, walls; falling into a pit or encountering the Wumpus causes death; grabbing the gold wins; agent has one arrow.
- Percepts (per cell)
  - Stench: Wumpus is in a neighboring cell.
  - Breeze: a pit is in a neighboring cell.
  - Glitter: gold is in the cell.
  - Bump: agent hit a wall.
  - Scream: Wumpus was killed.
- Coordinates and start
  - Cells denoted Cij (i = row, j = column). Start at C11.
  - Initial percepts at C11: no stench, no breeze, no glitter, etc.
  - From initial percepts, C21 and C12 are safe.
- Exploration sequence and logical deductions
  - Enter C21: breeze perceived → pit must be in C31 or C22.
  - Enter C12: stench perceived → implies Wumpus is in one of C11, C12, C22, C13.
  - Prior facts show C11 and C12 are not Wumpus cells → C22 and C11 eliminated by resolution using earlier “not W” facts and the stench clause → deduced Wumpus is in C13.
- Logical formalization and rules used
  - Predicates: SIJ = stench at Cij, BIJ = breeze at Cij, WIJ = Wumpus at Cij.
  - Knowledge base consists of implications (if-then rules) linking percepts to neighboring-state literals (e.g., ¬S11 ⇒ ¬W11 ∧ ¬W21 ∧ ¬W12).
  - Inference rules applied: modus ponens, and-elimination, resolution (to eliminate candidate Wumpus locations).
- Limitations of propositional encoding
  - Propositional logic requires enumerating every cell and implication explicitly (no variables, functions, or relations), making representations cumbersome.
  - Desire for a more compact representation using indexed/variable forms such as: ¬Sij ⇒ ¬Wij ∧ ¬W(i−1)j ∧ ¬W(i+1)j ∧ ¬Wij−1 ∧ ¬Wij+1, and Sij ⇒ Wij ∨ W(i−1)j ∨ W(i+1)j ∨ Wij−1 ∨ Wij+1.
- Open question (left implicit)
  - Whether the compact, variable-based representation can be used to replace the exhaustive propositional encoding.

- Resolution basics
  - Unit resolution: p ∨ q, ¬q ⊢ p.
  - Binary resolution: p ∨ q, ¬q ∨ r ⊢ p ∨ r.
  - Add proof by contradiction: negate query, add to KB, derive contradiction (empty clause) ⇒ original query entailed.

- Conjunctive Normal Form (CNF) requirements
  - CNF = conjunction of disjunctions (clauses).
  - Steps to convert first-order sentences to CNF:
    1. Eliminate implications: P → Q ≡ ¬P ∨ Q.
    2. Move negations inward / reduce scope (De Morgan, double negation).
    3. Rename variables to avoid name clashes (standardize apart).
    4. Eliminate existential quantifiers via Skolemization (introduce Skolem constants/functions).
    5. Move universal quantifiers left, then drop them.
    6. Distribute to obtain conjunction of disjunctions and split conjunctions into separate clauses.
    7. Standardize variables apart across clauses so same variable name in different clauses refers to different objects.

- Example knowledge base (text → FOL)
  - Natural language facts:
    - Whoever can read is literate.
    - Dolphins are not literate.
    - Some dolphins are intelligent.
  - FOL formalization:
    - ∀x (reads(x) → literate(x))
    - ∀x (dolphin(x) → ¬literate(x))
    - ∃x (dolphin(x) ∧ intelligent(x))
  - Query: ∃x (intelligent(x) ∧ ¬reads(x)) — “some intelligent cannot read”

- Converting the query for refutation
  - Negate the query and convert to universally quantified CNF form:
    - ¬∃x (intelligent(x) ∧ ¬reads(x)) ⇒ ∀x (¬intelligent(x) ∨ reads(x))
  - Skolemize the existential in the KB: introduce constant a for “some dolphin that is intelligent” ⇒ dolphin(a), intelligent(a).
  - After dropping universals and splitting, obtain clauses (standardized apart with subscripts if needed), including the negated-query clause ¬intelligent(x3) ∨ reads(x3).

- Resolution proof (using set-of-support / starting from negated query)
  - Unify ¬intelligent(x3) with intelligent(a) using θ1 = {x3/a} ⇒ derive reads(a).
  - Unify reads(a) with clause ¬reads(x1) using θ2 = {x1/a} ⇒ derive literate(a).
  - Unify literate(a) with clause ¬literate(x2) ∨ ¬dolphin(x2) using θ3 = {x2/a} ⇒ derive ¬dolphin(a).
  - Unify ¬dolphin(a) with dolphin(a) ⇒ derive empty clause (contradiction).
  - Contradiction implies original query is entailed by the KB.

- Implementation and practical notes
  - Resolution is a search process; strategies include unit resolution and set-of-support (start resolving from negated query).
  - Must record and apply substitution lists (θ) during unification.
  - Backtracking and multiple resolution trees may be required to find a proof or construct substitution sets.
  - Sometimes the substitution set itself (witness constants) is the desired result.
  - Resolution underlies logic programming languages such as Prolog.